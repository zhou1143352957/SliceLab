# 04 请求与拦截器

## 适用范围

- 新增接口、统一鉴权、处理错误码时使用。

## 规则

- 基于统一 `request` 封装，不在页面里直接裸调 `uni.request`。
- 跨端 API 统一使用 `uni.*`，禁止在业务层直接使用 `wx.*` / `my.*` / `plus.*`。
- CORS 是浏览器同源策略问题（协议/域名/端口任一不同即跨域），核心发生在 H5 调用接口场景。
- 部署阶段优先同域部署前后端；异域部署时由服务端显式放开允许来源（白名单优先）。
- 调试阶段优先使用 HBuilderX 内置浏览器或本地代理（如 dev-server proxy），浏览器跨域插件仅作临时手段。
- 浏览器跨域插件通常只适用于简单请求调试，涉及预检（OPTIONS）与线上联调仍需服务端配合。
- H5 调用 uniCloud `callFunction` 需在 uniCloud 控制台配置域名白名单。
- 请求层默认使用 TypeScript：入参、出参、错误体都使用类型定义，禁止大范围 `any`。
- `request` 封装提供泛型返回（如 `request<T>`），业务接口按契约显式声明 `T`。
- 在请求前统一注入 `Authorization` 或业务头。
- 业务错误码在响应层集中处理，页面只处理展示逻辑。
- 接口按域拆分，命名采用 `getXxx`/`createXxx` 等动词前缀。

## 示例

- `src/api/user.ts` 仅暴露语义化方法。
- `getUserProfile(): Promise<UserProfileDTO>` 这类返回值类型与接口契约保持一致。
- `request<ListResp<OrderDTO>>('/order/list', params)` 由泛型约束响应结构。
- H5 联调跨域时，优先走本地代理转发，避免直接依赖浏览器插件改安全策略。
- uniCloud H5 场景先配置域名白名单，再验证 `callFunction` 连接。
- 401 统一触发登录态失效流程。
- 缓存、请求、上传统一走 `uni.getStorage` / `uni.request` / `uni.uploadFile`。

## 反例

- 同一错误码在多个页面重复处理，逻辑分叉。
- 请求超时、重试策略到处手写，无法统一维护。
- 接口返回直接写 `Promise<any>`，导致调用层缺少类型约束。
- 把浏览器插件当成线上跨域方案，导致生产环境请求失败。
- 忽略预检请求（OPTIONS）处理，仅靠前端改请求头“绕过”跨域。
- 小程序端直接写 `wx.request`，导致跨端不可复用。

## 检查项

- 是否所有接口都走统一封装层。
- 错误处理是否分层：网络层/业务层/展示层。
- 请求与响应类型是否在编译期可校验并与接口契约一致。
- H5 场景是否有明确的跨域治理方案（同域/服务端 CORS/本地代理）。
- 线上接口是否已验证预检请求与来源白名单配置。
- 鉴权丢失时是否可自动回收状态并引导重登。
- 业务代码中是否残留平台私有 API 前缀。

## 来源

- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/
- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/typescript-subject.html
- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/CORS.html

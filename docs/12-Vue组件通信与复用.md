# 12 Vue 组件通信与复用

## 适用范围

- 父子组件通信、插槽设计、组件注册与复用策略制定时使用。

## 规则

- 组件注册优先使用 `easycom`；仅在必要场景使用局部 `import + components` 注册。
- 全局注册仅在确有跨页面复用需求时使用；`Vue.component` 首参必须为静态字符串。
- `nvue` 页面不依赖全局组件注册能力，优先局部或 easycom 方式。
- `props` 可用数组或对象声明；生产规则优先对象写法，补齐 `type/default/required/validator`。
- `props` 数据流保持单向下行，子组件禁止直接修改父级 `prop`。
- 自定义事件统一用 `$emit` 向上通知；避免滥用 `.native`（多端事件对象表现不一致）。
- 需要双向语义时优先显式事件约定；使用 `.sync` 时需明确同步边界，避免隐式副作用。
- `ref` 用于组件实例访问；非 H5 端不通过 `ref` 获取内置基础组件实例（如 `view/text`）。
- 插槽设计遵循编译作用域：父级插槽内容只能访问父级作用域，子级数据通过作用域插槽显式暴露。
- `v-slot` 仅写在 `<template>` 上；多插槽场景统一完整模板语法，避免默认缩写与具名混用。
- 小程序端不依赖动态组件、异步组件、`keep-alive`、`transition` 等受限能力。

## 示例

- easycom 目录规范组件直接在模板使用，无需手动导入注册。
- `props` 用对象声明并设置默认值，数组/对象默认值通过工厂函数返回。
- 子组件通过 `$emit('change', payload)` 通知父组件更新状态。
- 作用域插槽通过 `<slot :user="user">` 暴露数据，父组件使用 `v-slot` 接收。

## 反例

- 在子组件内部直接改 `prop`，导致父子状态难以追踪。
- 在跨端项目中依赖 `.native` 获取统一事件对象，实际端上行为不一致。
- 在非 H5 端通过 `this.$refs.content` 获取 `view` 实例后直接操作，运行时失效。
- 同时使用默认插槽缩写与具名插槽，造成作用域不明确与告警。
- 在小程序链路依赖 `keep-alive` 或动态组件，导致功能不可用。

## 检查项

- 组件注册方式是否优先 easycom 且与目录规范一致。
- `props` 是否对象化声明并约束类型与默认值。
- 子组件是否仅通过 `$emit` 通知，不直接改父数据。
- 插槽语义是否符合编译作用域与 `v-slot` 语法约束。
- 受限能力（动态组件、`keep-alive`、`transition`）是否在小程序链路规避。

## 来源

- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/vue-components.html

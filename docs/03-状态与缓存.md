# 03 状态与缓存

## 适用范围

- 管理登录态、用户信息、跨页状态共享时使用。

## 规则

- 全局状态优先用 Pinia；历史项目可继续用 Vuex，但禁止同一业务域双栈并行维护。
- Vuex 目录固定为 `store/index` + `store/modules/*`，模块开启 `namespaced` 保持边界清晰。
- `main.js` 必须注入 `app.use(store)`；`nvue` 需要在 `createApp` 返回值中显式返回 `Vuex` 供映射辅助函数使用。
- 状态变更只允许通过 `mutation`，且 `mutation` 保持同步；异步流程统一放 `action` 再 `commit`。
- 组件层优先 `mapState/mapGetters/mapMutations/mapActions`，避免页面到处直接读写 `$store`。
- 持久化字段最小化，只存必要标识与凭据。
- `uni.setStorage` 与内存状态保持单向同步策略。
- 登出必须清理：token、用户信息、业务缓存。

## 示例

- `auth store` 管理 `token`、`userId`、`profile`。
- 启动时从 storage 恢复最小状态，再拉取详情。
- `store/modules/auth.js` 维护登录域状态，页面通过 `mapState('auth', ['token'])` 读取。
- 请求前由 `action` 统一刷新 token，再 `commit` 到状态与 storage。

## 反例

- 把整个接口响应对象直接持久化到本地。
- 多处页面各自维护 token，导致状态不一致。
- 在组件里直接写 `this.$store.state.auth.token = xxx`。
- 在 `mutation` 里写异步请求，导致状态追踪不可预测。

## 检查项

- 是否区分“全局状态”和“页面私有状态”。
- Vuex 是否按 `index/modules` 拆分并开启命名空间。
- `main.js` 与 `nvue` 注入链路是否完整（`app.use(store)` / 返回 `Vuex`）。
- 是否保证“异步在 action、同步在 mutation”。
- 缓存是否设置失效策略或刷新时机。
- 异常退出后是否能恢复到一致状态。

## 来源

- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/vue3-vuex.html

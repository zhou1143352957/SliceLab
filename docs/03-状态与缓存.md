# 03 状态与缓存

## 适用范围

- 管理登录态、用户信息、跨页状态共享时使用。

## 规则

- 全局状态优先用 Pinia；历史项目可继续用 Vuex，但禁止同一业务域双栈并行维护。
- Vue3 项目默认采用 Pinia，`main.js` 统一 `createPinia` 并 `app.use(pinia)` 完成注入。
- Pinia 建议按业务域拆分 `stores/*`，每个 store 只负责单一业务域状态与动作。
- 在 `setup store` 中声明的 `state/getter/action` 需完整返回，避免调试与运行时行为不一致。
- 从 Pinia store 解构状态时使用 `storeToRefs`，避免直接解构导致响应性丢失。
- 在 Options API 中接入 Pinia 时统一使用 `mapState/mapWritableState/mapActions` 辅助函数。
- Vuex 目录固定为 `store/index` + `store/modules/*`，模块开启 `namespaced` 保持边界清晰。
- `main.js` 必须注入 `app.use(store)`；`nvue` 需要在 `createApp` 返回值中显式返回 `Vuex` 供映射辅助函数使用。
- 状态变更只允许通过 `mutation`，且 `mutation` 保持同步；异步流程统一放 `action` 再 `commit`。
- 组件层优先 `mapState/mapGetters/mapMutations/mapActions`，避免页面到处直接读写 `$store`。
- 持久化字段最小化，只存必要标识与凭据。
- `uni.setStorage` 与内存状态保持单向同步策略。
- 登出必须清理：token、用户信息、业务缓存。

## 示例

- `auth store` 管理 `token`、`userId`、`profile`。
- 启动时从 storage 恢复最小状态，再拉取详情。
- `useAuthStore` 通过 `defineStore('auth', ...)` 定义登录域状态，页面中 `const { token } = storeToRefs(authStore)` 使用响应式字段。
- 页面中通过 `mapWritableState(useAuthStore, ['token'])` 管理可写状态，通过 `mapActions(useAuthStore, ['refreshToken'])` 触发异步动作。
- `store/modules/auth.js` 维护登录域状态，页面通过 `mapState('auth', ['token'])` 读取。
- 请求前由 `action` 统一刷新 token，再 `commit` 到状态与 storage。

## 反例

- 把整个接口响应对象直接持久化到本地。
- 多处页面各自维护 token，导致状态不一致。
- 直接 `const { token } = authStore` 解构 Pinia 状态，导致视图不更新。
- 在页面里绕过 store 直接操作持久化与缓存，导致状态与 storage 双写冲突。
- 在组件里直接写 `this.$store.state.auth.token = xxx`。
- 在 `mutation` 里写异步请求，导致状态追踪不可预测。

## 检查项

- 是否区分“全局状态”和“页面私有状态”。
- Pinia 是否按业务域拆分，且入口已完成 `app.use(pinia)` 注入。
- Pinia 状态解构是否通过 `storeToRefs` 保持响应性。
- Options API 页面是否统一使用 Pinia 映射辅助函数。
- Vuex 是否按 `index/modules` 拆分并开启命名空间。
- `main.js` 与 `nvue` 注入链路是否完整（`app.use(store)` / 返回 `Vuex`）。
- 是否保证“异步在 action、同步在 mutation”。
- 缓存是否设置失效策略或刷新时机。
- 异常退出后是否能恢复到一致状态。

## 来源

- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/vue3-vuex.html
- 官方教程（2026-02-11 查阅）：https://uniapp.dcloud.net.cn/tutorial/vue3-pinia.html
